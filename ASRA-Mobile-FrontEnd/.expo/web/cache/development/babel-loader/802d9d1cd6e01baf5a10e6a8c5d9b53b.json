{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = SourceLoaderUri;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _RenderTTree = _interopRequireDefault(require(\"./RenderTTree\"));\n\nvar _sourceLoaderContext = _interopRequireDefault(require(\"./context/sourceLoaderContext\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar ERROR_STATE = {\n  error: true,\n  resolvedHTML: null\n};\n\nfunction loadHTMLResource(uri, _ref) {\n  var body, headers, method, response, html;\n  return _regeneratorRuntime.async(function loadHTMLResource$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          body = _ref.body, headers = _ref.headers, method = _ref.method;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(fetch(uri, {\n            body: body,\n            headers: headers,\n            method: method\n          }));\n\n        case 3:\n          response = _context.sent;\n\n          if (!response.ok) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 7;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 7:\n          html = _context.sent;\n          return _context.abrupt(\"return\", {\n            resolvedHTML: html,\n            error: false\n          });\n\n        case 9:\n          return _context.abrupt(\"return\", ERROR_STATE);\n\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction useUriSourceLoader(_ref2) {\n  var source = _ref2.source,\n      onHTMLLoaded = _ref2.onHTMLLoaded;\n\n  var _ref3 = (0, _react.useState)({\n    error: false,\n    resolvedHTML: null\n  }),\n      _ref4 = _slicedToArray(_ref3, 2),\n      loadState = _ref4[0],\n      setState = _ref4[1];\n\n  var error = loadState.error;\n  (0, _react.useEffect)(function () {\n    var cancelled = false;\n\n    if (!error) {\n      setState({\n        error: false,\n        resolvedHTML: null\n      });\n      loadHTMLResource(source.uri, {\n        body: source.body,\n        headers: source.headers,\n        method: source.method\n      }).then(function (state) {\n        !cancelled && setState(state);\n      }).catch(function () {\n        !cancelled && setState(ERROR_STATE);\n      });\n    }\n\n    return function () {\n      cancelled = true;\n    };\n  }, [error, source.uri, source.body, source.headers, source.method]);\n  (0, _react.useEffect)(function () {\n    loadState.resolvedHTML && (onHTMLLoaded === null || onHTMLLoaded === void 0 ? void 0 : onHTMLLoaded.call(null, loadState.resolvedHTML));\n  }, [loadState.resolvedHTML, onHTMLLoaded]);\n  return loadState;\n}\n\nfunction SourceLoaderUri(props) {\n  var _ref5 = (0, _react.useContext)(_sourceLoaderContext.default),\n      remoteErrorView = _ref5.remoteErrorView,\n      remoteLoadingView = _ref5.remoteLoadingView;\n\n  var _useUriSourceLoader = useUriSourceLoader(props),\n      resolvedHTML = _useUriSourceLoader.resolvedHTML,\n      error = _useUriSourceLoader.error;\n\n  if (error) {\n    return remoteErrorView.call(null, props.source);\n  }\n\n  if (resolvedHTML === null) {\n    return remoteLoadingView.call(null, props.source);\n  }\n\n  return _react.default.createElement(_RenderTTree.default, {\n    document: resolvedHTML,\n    baseUrl: props.source.uri\n  });\n}","map":{"version":3,"sources":["SourceLoaderUri.tsx"],"names":["ERROR_STATE","error","resolvedHTML","method","response","fetch","body","headers","html","onHTMLLoaded","cancelled","setState","loadHTMLResource","source","state","loadState","remoteLoadingView","sourceLoaderContext","useUriSourceLoader","remoteErrorView","props","RenderTTree","document","baseUrl","uri"],"mappings":"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","sourcesContent":["import React, { useContext, useEffect, useState } from 'react';\nimport { HTMLSourceUri } from './shared-types';\nimport { SourceLoaderProps } from './internal-types';\nimport RenderTTree from './RenderTTree';\nimport sourceLoaderContext from './context/sourceLoaderContext';\n\ninterface LoaderInternalState {\n  error: boolean;\n  resolvedHTML: string | null;\n}\n\nconst ERROR_STATE = {\n  error: true,\n  resolvedHTML: null\n};\n\nasync function loadHTMLResource(\n  uri: string,\n  { body, headers, method }: Omit<HTMLSourceUri, 'uri'>\n): Promise<LoaderInternalState> {\n  const response = await fetch(uri, {\n    body,\n    headers,\n    method\n  });\n  if (response.ok) {\n    const html = await response.text();\n    return {\n      resolvedHTML: html,\n      error: false\n    };\n  }\n  return ERROR_STATE;\n}\n\nexport type UriSourceLoaderProps = {\n  source: HTMLSourceUri;\n} & SourceLoaderProps;\n\nfunction useUriSourceLoader({ source, onHTMLLoaded }: UriSourceLoaderProps) {\n  const [loadState, setState] = useState<LoaderInternalState>({\n    error: false,\n    resolvedHTML: null\n  });\n  const { error } = loadState;\n\n  // Effect to reload on uri changes\n  useEffect(() => {\n    let cancelled = false;\n    if (!error) {\n      setState({ error: false, resolvedHTML: null });\n      loadHTMLResource(source.uri, {\n        body: source.body,\n        headers: source.headers,\n        method: source.method\n      })\n        .then((state) => {\n          !cancelled && setState(state);\n        })\n        .catch(() => {\n          !cancelled && setState(ERROR_STATE);\n        });\n    }\n    return () => {\n      cancelled = true;\n    };\n  }, [error, source.uri, source.body, source.headers, source.method]);\n  useEffect(() => {\n    loadState.resolvedHTML && onHTMLLoaded?.call(null, loadState.resolvedHTML);\n  }, [loadState.resolvedHTML, onHTMLLoaded]);\n  return loadState;\n}\n\nexport default function SourceLoaderUri(props: UriSourceLoaderProps) {\n  const { remoteErrorView, remoteLoadingView } =\n    useContext(sourceLoaderContext);\n  const { resolvedHTML, error } = useUriSourceLoader(props);\n  if (error) {\n    return remoteErrorView.call(null, props.source);\n  }\n  if (resolvedHTML === null) {\n    return remoteLoadingView.call(null, props.source);\n  }\n  return React.createElement(RenderTTree, {\n    document: resolvedHTML!,\n    baseUrl: props.source.uri\n  });\n}\n"]},"metadata":{},"sourceType":"script"}